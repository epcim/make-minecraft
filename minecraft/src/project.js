
// project.js
//
// Copyright (C) 2014 Kano Computing Ltd
// License: GNU General Public License v2 http://www.gnu.org/licenses/gpl-2.0.txt
//
// Create project object, put all project objects and class in here
//

var Project = new ProjectBase(13, 'make-minecraft/minecraft/content/minecraft-tutorial.xml', "minecraft", true);

Project.onload = function() {
    ProjectBase.prototype.init.call(Project);
};

window.addEventListener('load', Project.onload);

Project.reload = function() {
    ProjectBase.prototype.reload.call(Project);

    // Lazy-load the syntax-highlighting.
    window.setTimeout(BlocklyApps.importPrettify, 1);
};

Project.levelUpCaching = function (newLevel) {
    // Copy the cached blocks to the new level.
    if ('BlocklyStorage' in window) {
        BlocklyStorage.clearProjectCache(newLevel);
    }
};

/*
 * Sends the user to the seleted level stored in localStorage
 */
Project.goToStored = function(callback) {
    $('.shareDialog').stop().hide();
    if (typeof callback === 'function') {
        var level = callback();
        Project.switch(level);
    }
};

Project.getLastVisited = function() {
    var level = localStorage.minecraftLastLevelVisited;
    if (typeof level === 'undefined' || level === null) {
        localStorage.minecraftLastLevelVisited = Project.level;
        return Number(localStorage.minecraftLastLevelVisited);
    }
    return Number(localStorage.minecraftLastLevelVisited);
};

Project.setLastVisited = function(projectNumber) {
    localStorage.minecraftLastLevelVisited = projectNumber;
};

/**
 * Retrieves the code generated by the blocks
 * @return {string}  Code generated by the blocks
 */
Project.getCode = function() {
    var code = Blockly.Generator.workspaceToCode('Python');

    return code;
};

Project.isLevelComplete = function(code, data) {
    var blocks = Blockly.mainWorkspace.getTopBlocks(true),
        generator = Blockly.Generator.get('Python'),
        line;
    switch (data) {
        case 1:
            return true;
        case 2:
            for (var x = 0, block; block = blocks[x]; x++) {
                if (block.type == 'api_setFloor') {
                    line = generator.blockToCode(block);
                    if (line.indexOf('block.') != -1) {
                        if (line.indexOf('mc.player.getPos().x - 1 + 0') != -1
                            || line.indexOf('mc.player.getPos().z - 1 + 0') != -1) {

                            AlertsMessages.hint.displayMsg(Language.alert.hint.noFloor);
                            return false;
                        } else {
                            return true;
                        }
                    } else {
                        AlertsMessages.hint.displayMsg(Language.alert.hint.fillUpFloor);
                        return false;
                    }
                }
            }
            AlertsMessages.hint.displayMsg(Language.alert.hint.noFloorBlock);
            break;
        case 3:
            for (var x = 0, block; block = blocks[x]; x++) {
                if (block.type == 'api_setBlocks') {
                    line = generator.blockToCode(block);

                    if (line.indexOf('block.') != -1) {
                        if (line.indexOf('mc.player.getPos().x - 1 + 0') != -1
                            || line.indexOf('mc.player.getPos().z - 1 + 0') != -1) {

                            AlertsMessages.hint.displayMsg(Language.alert.hint.noFloor);
                            return false;
                        } else {
                            return true;
                        }
                    } else {
                        AlertsMessages.hint.displayMsg(Language.alert.hint.fillUpFloor);
                        return false;
                    }
                }
            }
            AlertsMessages.hint.displayMsg(Language.alert.hint.buildBlock);
            break;
        case 4:
            for (var x = 0, block; block = blocks[x]; x++) {
                if (block.type == 'api_setBlocks') {
                    line = generator.blockToCode(block);

                    if (line.indexOf('block.') != -1) {
                        if (line.indexOf('mc.player.getPos().x - 1 + 0') != -1
                            || line.indexOf('mc.player.getPos().z - 1 + 0') != -1) {

                            AlertsMessages.hint.displayMsg(Language.alert.hint.noFloor);
                            return false;
                        } else {
                            return true;
                        }
                    } else {
                        AlertsMessages.hint.displayMsg(Language.alert.hint.fillUpFloor);
                        return false;
                    }
                }
            }
            AlertsMessages.hint.displayMsg(Language.alert.hint.noFloorBlock);
            break;
        case 5:
            for (var x = 0, block; block = blocks[x]; x++) {
                if (block.type == 'api_setBlocks') {
                    line = generator.blockToCode(block);
                    var indexOfAir = line.indexOf('block.AIR');
                    if (indexOfAir != -1) {
                        if (Project.isBlockSolid(line)) {
                            if (line.indexOf('mc.player.getPos().x + 0 + 0') != -1
                                && line.indexOf('mc.player.getPos().y + 0 + 0') != -1
                                && line.indexOf('mc.player.getPos().z + 0 + 0') != -1) {

                                AlertsMessages.hint.displayMsg(Language.alert.hint.noTower);
                                return false;
                            } else {
                                return true;
                            }
                        } else { // Tower not solid
                            return false;
                        }
                    } else { // No door
                        AlertsMessages.hint.displayMsg(Language.alert.hint.makeDoor);
                        return false;
                    }
                }
            }

            AlertsMessages.hint.displayMsg(Language.alert.hint.makeDoor);
            break;
        case 6:
            for (var x = 0, block; block = blocks[x]; x++) {
                if (block.type == 'api_setBlocks') {
                    line = generator.blockToCode(block);
                    var indexOfLava = line.indexOf('block.LAVA');

                    if (indexOfLava != -1) {
                        if (Project.isBlockSolid(line)) {
                            if (line.indexOf('mc.player.getPos().x') != -1) {
                                if (line.indexOf('mc.player.getPos().x + 0 + 0') != -1
                                    && line.indexOf('mc.player.getPos().y + 0 + 0') != -1
                                    && line.indexOf('mc.player.getPos().z + 0 + 0') != -1) {

                                    AlertsMessages.hint.displayMsg(Language.alert.hint.noTower);
                                    return false;
                                } else {
                                    return true;
                                }
                            }
                        } else { // Volcano not solid
                            return false;
                        }
                    } else { // No lava block
                        AlertsMessages.hint.displayMsg(Language.alert.hint.makeVolcano);
                        return false;
                    }
                }
            }

            AlertsMessages.hint.displayMsg(Language.alert.noLevelUp);
            break;
        case 7:
            for (var x = 0, block; block = blocks[x]; x++) {
                if (block.type == 'api_postToChat') {
                    return true;
                }
            }
            AlertsMessages.hint.displayMsg(Language.alert.noLevelUp);
            break;
        case 8:
            for (var x = 0, block; block = blocks[x]; x++) {
                if (block.type == 'api_player_setTilePos') {
                    line = generator.blockToCode(block);
                    if (line.indexOf('mc.player.getPos().x + 0, mc.player.getPos().y + 0, mc.player.getPos().z + 0') != -1) {
                        AlertsMessages.hint.displayMsg(Language.alert.hint.noTeleport);
                        return false;
                    } else {
                        return true;
                    }
                }
            }
            AlertsMessages.hint.displayMsg(Language.alert.hint.teleportBlock);
            break;
        case 9:
            for (var x = 0, block; block = blocks[x]; x++) {
                if (block.type == 'api_setBlocks') {
                    line = generator.blockToCode(block);
                    var indexOfFence = line.indexOf('block.FENCE');
                    if (indexOfFence != -1) {
                        if (Project.isBlockSolid(line)) {
                            if (line.indexOf('mc.player.getPos().x + 0 + 0') != -1
                                && line.indexOf('mc.player.getPos().y + 0 + 0') != -1
                                && line.indexOf('mc.player.getPos().z + 0 + 0') != -1) {

                                AlertsMessages.hint.displayMsg(Language.alert.hint.noTower);
                                return false;
                            } else {
                                if (!Project.noTeleport(line)) {
                                    return true;
                                }
                            }
                        } else { // Tower not solid
                            return false;
                        }
                    } else { // No fence
                        AlertsMessages.hint.displayMsg(Language.alert.hint.noFence);
                        return false;
                    }
                }
            }
            break;
        case 10:
            for (var x = 0, block; block = blocks[x]; x++) {
                if (block.type == 'api_setBlocks') {
                    line = generator.blockToCode(block);
                    if (Project.isBlockSolid(line)) {
                        if (line.indexOf('mc.player.getPos().x + 0 + 0') != -1
                            && line.indexOf('mc.player.getPos().y + 0 + 0') != -1
                            && line.indexOf('mc.player.getPos().z + 0 + 0') != -1) {

                            AlertsMessages.hint.displayMsg(Language.alert.hint.noTower);
                            return false;
                        } else {
                            return true;
                        }
                    } else { //not solid
                        return false;
                    }
                }
            }

            AlertsMessages.hint.displayMsg(Language.alert.hint.makeDoor);
            break;
        case 11:
            for (var x = 0, len = blocks.length; x < len; x++) {
                if (blocks[x].type === 'controls_whileUntil') {
                    if (blocks[x].inputList[0].titleRow[1].text_ === 'until') {
                        var setBlock = blocks[x].childBlocks_[0];

                        if (setBlock !== undefined && setBlock.type === 'api_setBlocks') {
                            var setBlkChild = setBlock.childBlocks_;
                            line = generator.blockToCode(setBlock);

                            if (line.indexOf('mc.setBlocks(mc.player.getPos().x + 0, mc.player.getPos().y + 0, mc.player.getPos().z + 0, mc.player.getPos().x + 0 + 0, mc.player.getPos().y + 0 + 0, mc.player.getPos().z + 0 + 0, block.') !== -1) {
                                if (setBlkChild.length === 4) {
                                    var sleep = setBlkChild[3];
                                    line = generator.blockToCode(sleep);

                                    if (line.indexOf('time.sleep(') !== -1) {
                                        if (line.indexOf('(0)') === -1) {
                                            return true;
                                        } else { // Sleep is 0.
                                            AlertsMessages.hint.displayMsg(Language.alert.hint.zeroSleep);
                                            return false;
                                        }
                                    } else { // No sleep block
                                        AlertsMessages.hint.displayMsg(Language.alert.hint.noSleep);
                                        return false;
                                    }
                                }
                            } else { // Not enough inputs to setBlocks
                                AlertsMessages.hint.displayMsg(Language.alert.hint.notEnoughInputs);
                                return false;
                            }
                        } else { // The block is not setBlocks
                            AlertsMessages.hint.displayMsg(Language.alert.hint.noSetBlocks);
                            return false;
                        }
                    } else { // Loop is not set to until
                        AlertsMessages.hint.displayMsg(Language.alert.hint.loopNotUntil);
                        return false;
                    }
                }
            }

            AlertsMessages.hint.displayMsg(Language.alert.hint.noWhileLoop);
            break;
        case 12:
            for (var x = 0, len = blocks.length; x < len; x++) {
                if (blocks[x].type === 'controls_whileUntil') {
                    if (blocks[x].inputList[0].titleRow[1].text_ === 'until') {
                        var sleep = blocks[x].childBlocks_[0];

                        if (sleep !== undefined && sleep.type === 'api_sleep') {
                            line = generator.blockToCode(sleep);

                            if (line.indexOf('time.sleep(0)') === -1) {
                                var ifBlk = sleep.childBlocks_[1];

                                if (ifBlk !== undefined && ifBlk.type === 'controls_if') {
                                    var compare   = ifBlk.childBlocks_[0],
                                        setBlocks = ifBlk.childBlocks_[1];

                                    if (compare !== undefined && compare.type === 'logic_compare') {
                                        line = generator.blockToCode(compare);

                                        var blocktype = 'block.WATER_STATIONARY',
                                            position  = 'mc.getBlockWithData(mc.player.getPos().x + 0, mc.player.getPos().y + 0, mc.player.getPos().z + 0)';
                                        if (line.indexOf(blocktype + ' == ' + position) !== -1 || line.indexOf(position + ' == ' + blocktype) !== -1) {
                                            // Condition corrent
                                        } else { // incorrect condition
                                            AlertsMessages.hint.displayMsg(Language.alert.hint.wrongCompare);
                                            return false;
                                        }
                                    } else { // The block is not compare
                                        AlertsMessages.hint.displayMsg(Language.alert.hint.noCompare);
                                        return false;
                                    }

                                    if (setBlocks !== undefined && setBlocks.type === 'api_setBlocks') {
                                        var setBlkChild = setBlocks.childBlocks_;
                                        line = generator.blockToCode(setBlocks);

                                        if (setBlkChild.length >= 3) {
                                            if (line.indexOf('mc.setBlocks(mc.player.getPos().x + 0, mc.player.getPos().y + 0, mc.player.getPos().z + 0, mc.player.getPos().x + 0 + 0, mc.player.getPos().y + 0 + 0, mc.player.getPos().z + 0 + 0, block.') !== -1) {
                                                return true;
                                            } else { // incorrect inputs
                                                AlertsMessages.hint.displayMsg(Language.alert.hint.notEnoughInputs);
                                                return false;
                                            }
                                        } else { // Not enough inputs to setBlocks
                                            AlertsMessages.hint.displayMsg(Language.alert.hint.notEnoughInputs);
                                            return false;
                                        }
                                    } else { // The block is not set blocks
                                        AlertsMessages.hint.displayMsg(Language.alert.hint.noSetBlocks);
                                        return false;
                                    }

                                } else { // The block is not if
                                    AlertsMessages.hint.displayMsg(Language.alert.hint.noIf);
                                    return false;
                                }
                            } else { // Sleep can't be 0
                                AlertsMessages.hint.displayMsg(Language.alert.hint.zeroSleep);
                                return false;
                            }
                        } else { // The block is not sleep
                            AlertsMessages.hint.displayMsg(Language.alert.hint.noSleep);
                            return false;
                        }
                    } else { // Loop is not set to until
                        AlertsMessages.hint.displayMsg(Language.alert.hint.loopNotUntil);
                        return false;
                    }
                }
            }

            AlertsMessages.hint.displayMsg(Language.alert.hint.noWhileLoop);
            break;

        case 13:
            var line;
            for (var x = 0, len = blocks.length; x < len; x++) {
                line = generator.blockToCode(blocks[x]);
                if (blocks[x].type === 'setVariable') {
                    if (line.indexOf('mc.setBlocks') !== -1) {
                        if (!Project.noBlock(line)) {
                            var incrementCode = 'x = x +';
                            if (line.indexOf(incrementCode) !== -1) {
                                return true;
                            }
                            else {
                                AlertsMessages.hint.displayMsg(Language.alert.hint.noIncrementOnVar);
                                return false;
                            }
                        }
                        else return false;
                    }
                    else {
                        AlertsMessages.hint.displayMsg(Language.alert.hint.noSetBlocks);
                        return false;
                    }

                }
                AlertsMessages.hint.displayMsg(Language.alert.hint.noVarBlock);
                return false;
            }


            break;
    }

    return false;
};

/* This displays an alert if the MC user puts a completely empty "Set Player Position" block on the workspace */
Project.noTeleport = function(code) {
    if (code.indexOf('mc.player.setTilePos( mc.player.getPos().x + 0, mc.player.getPos().y + 0, mc.player.getPos().z + 0') != -1) {
        AlertsMessages.hint.displayMsg(Language.alert.hint.noTeleport);
        return true;
    }

    return false;
};

/* This displays an alert if the MC user puts a completely empty "Set blocks" block on the workspace */
Project.noBlock = function(code) {
    if (code.indexOf('mc.setBlocks(mc.player.getPos().x + 0, mc.player.getPos().y + 0, mc.player.getPos().z + 0, mc.player.getPos().x + 0 + 0, mc.player.getPos().y + 0 + 0, mc.player.getPos().z + 0 + 0, 0)') != -1 ||
        code.indexOf('mc.setBlocks(mc.player.getPos().x + 0, mc.player.getPos().y + 0, mc.player.getPos().z + 0, mc.player.getPos().x + 0 + 0, mc.player.getPos().y + 0 + 0, mc.player.getPos().z + 0 + 0, block.AIR)') != -1) {

        AlertsMessages.hint.displayMsg(Language.alert.hint.noBlock);
        return true;
    }

    return false;
};

Project.isBlockSolid = function(code) {
    var solidBlocks = [
        'STONE_BRICK',
        'GRASS',
        'DIAMOND_BLOCK',
        'ICE',
        'TNT',
        'WOOD',
        'GLASS',
        'FENCE'
    ];

    for (var i = 0, len = solidBlocks.length; i < len; i++) {
        if (code.indexOf('block.' + solidBlocks[i]) !== -1) {
            return true;
        }
    }

    AlertsMessages.hint.displayMsg(Language.alert.hint.notSolidBlock);
    return false;
};

Project.blockIsAir = function(code) {
    if (code.indexOf('block.STONE_BRICK') != -1 ||
        code.indexOf('block.GRASS') != -1 ||
        code.indexOf('block.DIAMOND_BLOCK') != -1 ||
        code.indexOf('block.LAVA_STATIONARY') != -1 ||
        code.indexOf('block.TNT') != -1 ||
        code.indexOf('block.ICE') != -1 ||
        code.indexOf('block.WATER_STATIONARY') != -1) {
            return false;
    }

    AlertsMessages.hint.displayMsg(Language.alert.hint.blockIsAir);
    return true;
};
